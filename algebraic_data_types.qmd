# Algebraic Data Types

Definintion

## Product Types

* explain product types
  * https://jrsinclair.com/articles/2019/algebraic-data-types-what-i-wish-someone-had-explained-about-functional-programming

* exist in:
  * Js/Ts (Arrays, Objects, Maps, WeakMaps)
  * Python (Lists, Records, ..)
  * PHP
  * Java
  * C#
  * C++ (Classes, Structs, ..)
  * C (Structs, ..)
  * Go
  * Rust (Structs, ..)

## Sum Types

* explain sum types
  * https://jrsinclair.com/articles/2019/algebraic-data-types-what-i-wish-someone-had-explained-about-functional-programming/

* exist in: (https://en.wikipedia.org/wiki/Algebraic_data_type)
  * C++, Java 15, Rust, TypeScript
  * F#, Haskell, Idris, Kotlin, Nim, Swift

### Enums

```rust
// Declare an enum.
enum Type {
  Ok,
  NotOk,
}

// Declare a specific enum field.
const c = Type.Ok
```

<!-- ```rust
// TODO
// If you want access to the ordinal value of an enum, you
// can specify the tag type.
const Value = enum(u2) {
  Zero,
  One,
  Two,
}
// Now you can cast between u2 and Value.
// The ordinal value starts from 0, counting up by 1 from the previous member.
test "enum ordinal value" {
  assert_eq(@enumToInt(Value.Zero), 0)
  assert_eq(@enumToInt(Value.One), 1)
  assert_eq(@enumToInt(Value.Two), 2)
}
``` -->

You can override the ordinal value for an `enum`.

```rust
enum Value2 {
  Hundred = 100,
  Thousand = 1_000,
  Million = 1_000_000,
}
test "set enum ordinal value" {
  // TODO: How to convert enum to int/uint?
  assert_eq(@enumToInt(Value2.Hundred), 100)
  assert_eq(@enumToInt(Value2.Thousand), 1000)
  assert_eq(@enumToInt(Value2.Million), 1000000)
}
```

You can also override only some values.

```rust
enum Value3 {
  A,
  B = 8,
  C,
  D = 4,
  E,
}
test "enum implicit ordinal values and overridden values" {
  assert_eq(@enumToInt(Value3.A), 0)
  assert_eq(@enumToInt(Value3.B), 8)
  assert_eq(@enumToInt(Value3.C), 9)
  assert_eq(@enumToInt(Value3.D), 4)
  assert_eq(@enumToInt(Value3.E), 5)
}
```

`Enum`s can have methods, the same as `struct`s.
`Enum` methods are not special, they are only namespaced functions that you can call with dot syntax.

```rust
enum Suit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,

  pub fn isClubs(self: Suit) bool {
    self == Suit.Clubs
  }
}
test "enum method" {
  const suit = Suit.Spades
  assert_eq(suit.isClubs(), false)
}
```

An `enum` can be `match`ed upon.

```rust
enum Foo {
  String,
  Number,
  None,
}
test "enum match" {
  const foo = Foo.Number
  const what_is_it = match foo {
    Foo.String => "this is a string",
    Foo.Number => "this is a number",
    Foo.None => "this is a none",
  }
  assert_eq(what_is_it, "this is a number")
}
```

<!-- ```rust
// TODO
// `@typeInfo` can be used to access the integer tag type of an enum.
enum Small {
  One,
  Two,
  Three,
  Four,
}
test "std.meta.Tag" {
  assert_eq(@typeInfo(Small).Enum.tag_type, u2)
}

// `@typeInfo` tells us the field count and the fields names:
test "@typeInfo" {
  assert_eq(@typeInfo(Small).Enum.fields.len, 4)
  assert_eq(@typeInfo(Small).Enum.fields[1].name, "Two")
}

// `@tagName` gives a `string` representation of an enum value:
test "@tagName" {
  assert_eq(@tagName(Small.Three), "Three")
}
``` -->

### Non-exhaustive enum

A Non-exhaustive enum can be created by adding a trailing `_` field. It must specify a tag type and cannot consume every enumeration value.

```rust
enum Number {
  One,
  Two,
  Three,
  _,
}

test "match on non-exhaustive enum" {
  const number = Number.One
  const result = match number {
    .One => true,
    .Two | .Three => false,
    _ => false,
  }
  assert(result)
  const is_one = match number {
      .One => true,
      else => false,
  }
  assert(is_one)
}
```


## Optional Values

* null references, the billion dollar mistake
  * https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/
  * https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/
  * https://en.wikipedia.org/wiki/Tony_Hoare

* Ts
  * `null`, `undefined`
  * can be detected by Ts compiler
* Java, C, C++, ..
* Rust
  * `Option` enum
  * must be unwrapped to use the value

* `Option`s replace null references
  * is a sum type / enum

@adhocp_1989
