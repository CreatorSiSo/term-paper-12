<!-- # Concept of a modern programming language -->
# Konzept einer modernen Programmiersprache

<!--
Rym is a general purpose language designed to work at a level above systems
programming, while still allowing the use of lower level features when required.
Although both an interpreter and a compiler can be used to implement Rym,
the current implementation is an interpreter.
However, this description makes no assumptions about the
implementation and enables a future compiled version.
-->
Rym ist eine Sprache für allgemeine Zwecke, die auf einer höheren Ebene als die System
Programmierung arbeitet, aber dennoch die Verwendung von tieferliegenden Funktionen erlaubt, wenn dies erforderlich ist.
Obwohl sowohl ein Interpreter als auch ein Kompiler zur Umsetzung der Sprache verwendet werden können,
ist die derzeitige Implementierung ein Interpreter.
Diese Beschreibung macht jedoch keine Annahmen über die
Implementierung und ermöglicht eine zukünftige kompilierte Version.

## Syntax {#sec-syntax}

Which syntax the user of a language prefers is their subjective opinion and it is not possible to give a subjective best answer.
But most programmers are used to a C-style syntax which is why Rym,
like Kotlin, Rust, Dart, and others simply adapts it.
Actual functional changes happen at the semantic level.

- __TODO__
  - naming: @sebesta_2019 S. 344
  - simple
  - expressive
  - flat learning curve
  - familiar syntax
  - `{}` is a block (vs. `end`/`end if`)
  - might not make as much sense for non-programmers
  - comparable with the way that `+` and other math notation could be considered less readable then `plus`

<!-- __TODO Explain difference between syntax and semantics__ -->

<!-- As is advantageous if not everything is completely new when getting to know the language,
as it can then be learned more quickly if you already know how to program. -->

## General Structure {#sec-general-structure}

Rym's execution model is based on packages, which can be either a library or an executable.
Packages containing a "main" function can be run as standalone programs, while others are reusable libraries.
These packages are made up of modules, functions, constants and other definitions that form a tree-like structure,
that provides organisation for the code.
__TODO Mention where the constructs are explained in detail__

Source files that represent a top-level module use the .rym extension.
To better adhere to the __TODO__ principle, Rym also allows the execution of ".rys" script files.
These scripts work much like a JavaScript or Python file,
where all statements are executed immediately without the need to define an entry function.
Rym achieves this by simply wrapping the contents of the script in a main function.

A look at the typical "Hello World!" script shows what this transformation looks like in practice _(main.rys)_ :

```rym
print("Hello World!")
```

It is just as simple as a Python version that does the same thing, but actually corresponds to this module file _(main.rym)_ :

```rym
func main() -> () {
  print("Hello World!")
}
```

## Modules {#sec-modules}

In Rym, modules are the building blocks of a package and provide a way to organize code into logical units.
Each module can contain its own functions, constants, and other definitions.
Modules can be imported into other modules, allowing for the reuse of code.

## Data Types {#sec-data-types}

Rym provides a rich set of data types, including primitive types (such as integers, floats, and strings)
and composite types (such as arrays and tuples). Rym also provides support for algebraic data types,
which allow for the creation of custom, named data types.

### Primitive Data Types {#sec-primitive-data-types}

Rym provides a set of basic data types such as integers, floating-point numbers, strings, and booleans.
These types can be used to build more complex data structures.

### Algebraic Data Types {#sec-algebraic-data-types}

Algebraic data types (ADTs) in Rym provide a way to create custom, named data types that can be used in the same way as other built-in types.
ADTs can be constructed from primitive types or other ADTs, and can be used to model complex data structures in a type-safe manner.

## Functions {#sec-functions}

Functions in Rym are first-class citizens, just like values and data types.
They are blocks of code that can be passed as parameters, assigned to variables, and used in expressions.
Functions can return values and accept parameters, which makes them powerful tools for creating modular, reusable code.

## Higher Order Functions

Functions in Rym can be used as values, just like booleans, numbers and strings.
They are also higher order functions, meaning that they can be used as arguments to another function, or they can be a function's result.
@higher_order_func

Because functions are a data type

- closures: [@sebesta_2019 S. 665]

To allow for easier declaration of functions inline

```rym
func twice(f: func(int) -> int) -> func(int) -> int {
  x -> f(f(x))
}

func plus_three(i: int) -> int {
  i + 3
}

func main() {
  const specific_twice = twice(plus_three)

  print(f"{specific_twice(7)}") // 13
}
```


## Bindings and Scope {#sec-bindings-and-scope}

Bindings in Rym are the association of a name with a value, and scope determines the accessibility of these bindings.
Rym has both global and local scopes, and bindings declared in a local scope are only accessible within that scope.

Immutable

```rym
const example_1 = 99
example_1 = 100     // error: Cannot assing to immutable variable example_1
print(example_1)
```

Mutable

```rym
mut example_1 = 99
example_1 = 100
print(example_1) // prints "100"
```

__TODO__

## Operators

Rym provides a set of unary and binary operators.
The unary operators include the "!" operator used to invert the value of a boolean,
the "-" operator used to negate numbers
and the "?" operator.
The last operator unwraps types like _Option_ or _Result_
and returns the value out of the current function if an unsuccessfull variant (_None_, _Err_) is met.^[Beispiel siehe @sec-qestion-mark-op]
Rym does not support the "++" and "-\-" operators,
which are often used increment or decrement an integer,
as it is often unclear what these operators exactly do.
The same

The assignment operators can only be used with variables that are marked as mutable (via mut keyword).

## Control Flow {#sec-control-flow}

Control flow in Rym is achieved through the use of conditional statements (if/else) and loops (for/while).
Rym also provides a mechanism for early exits from loops or functions through the use of return statements.

## Tooling and Ecosystem {#sec-tooling-and-ecosystem}

Rym has a growing ecosystem of tools and libraries that make it easier to develop, test, and deploy applications.
These tools include IDEs, text editors with Rym plugins, build tools, package managers, and libraries for various domains.
Rym's tooling and ecosystem are designed to be flexible and allow for easy integration with other systems and technologies.
