<!-- # Concept of a modern programming language -->
# Konzept einer modernen Programmiersprache

<!--
Rym is a general purpose language designed to work at a level above systems
programming, while still allowing the use of lower level features when required.
Although both an interpreter and a compiler can be used to implement Rym,
the current implementation is an interpreter.
However, this description makes no assumptions about the
implementation and enables a future compiled version.
-->
Rym ist eine Sprache für allgemeine Zwecke, die auf einer höheren Ebene als die System
Programmierung arbeitet, aber dennoch die Verwendung von tieferliegenden Funktionen erlaubt, wenn dies erforderlich ist.
Obwohl sowohl ein Interpreter als auch ein Kompiler zur Umsetzung der Sprache verwendet werden können,
ist die derzeitige Implementierung ein Interpreter.
Diese Beschreibung macht jedoch keine Annahmen über die
Implementierung und ermöglicht eine zukünftige kompilierte Version.

## Syntax

<!--
The syntax follows the aspects mentioned in @sec-readability, especially @sec-syntax.
Rym can be considered part of the C-style languages, as it combines syntax from C, Go, Rust, F# and others.
The typical braces -- "{" and "}" -- are used for structure types and to enclose blocks of statements.
Function definitions begin with "func", just as they do in Go or Swift, and the type declarations are very similar to those in F#.
-->
Die Syntax folgt den in @sec-readability genannten Aspekten, insbesondere aus @sec-syntax.
Rym kann als Teil der C-ähnlichen Sprachen betrachtet werden, da es die Syntax von C, Go, Rust, F# und anderen verbindet.
Die typischen geschweiften Klammern -- "{" und "}" -- werden für Struktur-Typen und zum Umschließen von Anweisungsblöcken verwendet.
Funktionsdefinitionen beginnen mit "func", genau wie in Go oder Swift, und die Typ-Deklarationen sind denen in F# sehr ähnlich.
[@go_spec; @swift_book_functions; @fsharp_spec S. 39f]

<!--
However, it differs from typical C-style syntax in one major way: It is primarily expression-based, like Rust and F#.
This means that most forms of value-producing or effect-causing evaluation are controlled by the syntax category of expressions.
In contrast, statements are mostly used to contain and explicitly sequence the evaluation of expressions.
-->
In einem Punkt gibt es jedoch große Unterschiede zur typischen C-Syntax: Rym ist, wie Rust und F#, primär ausdrucksbasiert.
Das bedeutet, dass die meisten Formen der wertbildenden oder effektverursachenden Auswertung durch die Syntaxkategorie der Ausdrücke gesteuert werden.
Im Gegensatz dazu werden Anweisungen meist dazu verwendet, eine spezifische Reihe an Ausdrücken zu enthalten.
<!-- TODO explain why expressions are useful -->

<!--
Rym also has strict naming rules.
Names can only begin with the ASCII characters "a-z", "A-Z" or "\_". After that, the numbers "0-9" are also allowed.
This makes it easier for users to work together because the language forces them to write similar code.
Variable, function and module names are written in _snake\_case_,
user-defined types must use _PascalCase_ and the core built-in types such as "bool" are single lowercase words.
Snake case is used because the underscore improves readability.
Pascal case distinguishes types from values.
-->
Rym hat auch strikte Regeln für die Namensgebung.
Namen dürfen nur mit den ASCII-Zeichen "a-z", "A-Z" oder "\_" beginnen. Anschließend sind auch die Zahlen "0-9" erlaubt.
Dies erleichtert den Benutzern die Zusammenarbeit, da die Sprache sie veranlasst, ähnlichen Code zu schreiben.
Variablen-, Funktions- und Modulnamen werden in _snake\_case_ geschrieben,
benutzerdefinierte Typen müssen in _PascalCase_ geschrieben werden und die eingebauten Standardtypen wie "bool" bestehen aus einem kleinge-schriebenen Wort.
Snake-Case wird verwendet, da der Unterstrich die Lesbarkeit verbessert und Pascal-Case Typen von Werten unterscheidet.
[@sebesta_2019 S. 344fff]

<!-- __TODO Explain difference between syntax and semantics__ -->

<!-- ## Program Structure -->
## Programmstruktur

Rym's execution model is based on packages, which can be either a library or an executable.
Packages containing a "main" function can be run as standalone programs, while others are reusable libraries.
These packages are made up of modules, functions, constants and other definitions that form a tree-like structure,
that provides organisation for the code.
__TODO Mention where the constructs are explained in detail__

Source files that represent a top-level module use the .rym extension.
To better adhere to the __TODO__ principle, Rym also allows the execution of ".rys" script files.
These scripts work much like a JavaScript or Python file,
where all statements are executed immediately without the need to define an entry function.
Rym achieves this by simply wrapping the contents of the script in a main function.

A look at the typical "Hello World!" script shows what this transformation looks like in practice _(main.rys)_ :

```rym
print("Hello World!")
```

It is just as simple as a Python script that prints "Hello World!\n", but actually gets transformed to this module file _(main.rym)_ :

```rym
func main() -> () {
  print("Hello World!")
}
```

## Modules {#sec-modules}

In Rym, modules are the building blocks of a package and provide a way to organize code into logical units.
Each module can contain its own functions, constants, and other definitions.
Modules can be imported into other modules, allowing for the reuse of code.

## Data Types {#sec-data-types}

Rym provides a rich set of data types, including primitive types (such as integers, floats, and strings)
and composite types (such as arrays and tuples). Rym also provides support for algebraic data types,
which allow for the creation of custom, named data types.

### Primitive Data Types {#sec-primitive-data-types}

Rym provides a set of basic data types such as integers, floating-point numbers, strings, and booleans.
These types can be used to build more complex data structures.

### Algebraic Data Types {#sec-algebraic-data-types}

Algebraic data types (ADTs) in Rym provide a way to create custom, named data types that can be used in the same way as other built-in types.
ADTs can be constructed from primitive types or other ADTs, and can be used to model complex data structures in a type-safe manner.

## Functions {#sec-functions}

Functions in Rym are first-class citizens, just like values and data types.
They are blocks of code that can be passed as parameters, assigned to variables, and used in expressions.
Functions can return values and accept parameters, which makes them powerful tools for creating modular, reusable code.

## Higher Order Functions

Functions in Rym can be used as values, just like booleans, numbers and strings.
They are also higher order functions, meaning that they can be used as arguments to another function, or they can be a function's result.
@higher_order_func

Because functions are a data type

- closures: [@sebesta_2019 S. 665]

To allow for easier declaration of functions inline

```rym
func twice(f: func(int) -> int) -> func(int) -> int {
  x -> f(f(x))
}

func plus_three(i: int) -> int {
  i + 3
}

func main() {
  const specific_twice = twice(plus_three)

  print(f"{specific_twice(7)}") // 13
}
```


## Bindings and Scope {#sec-bindings-and-scope}

Bindings in Rym are the association of a name with a value, and scope determines the accessibility of these bindings.
Rym has both global and local scopes, and bindings declared in a local scope are only accessible within that scope.

Immutable

```rym
const example_1 = 99
example_1 = 100     // error: Cannot assing to immutable variable example_1
print(example_1)
```

Mutable

```rym
mut example_1 = 99
example_1 = 100
print(example_1) // prints "100"
```

__TODO__

## Operators

Rym provides a set of unary and binary operators.
The unary operators include the "!" operator used to invert the value of a boolean,
the "-" operator used to negate numbers
and the "?" operator.
The last operator unwraps types like _Option_ or _Result_
and returns the value out of the current function if an unsuccessfull variant (_None_, _Err_) is met.^[Beispiel siehe @sec-qestion-mark-op]
Rym does not support the "++" and "-\-" operators,
which are often used increment or decrement an integer,
as it is often unclear what these operators exactly do.
The same

The assignment operators can only be used with variables that are marked as mutable (via mut keyword).

## Control Flow {#sec-control-flow}

Control flow in Rym is achieved through the use of conditional statements (if/else) and loops (for/while).
Rym also provides a mechanism for early exits from loops or functions through the use of return statements.

## Tooling and Ecosystem {#sec-tooling-and-ecosystem}

Rym has a growing ecosystem of tools and libraries that make it easier to develop, test, and deploy applications.
These tools include IDEs, text editors with Rym plugins, build tools, package managers, and libraries for various domains.
Rym's tooling and ecosystem are designed to be flexible and allow for easy integration with other systems and technologies.

{{< pagebreak >}}
