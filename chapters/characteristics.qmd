<!-- # Advantageous Characteristics of Programming Languages -->
# Vorteilhafte Eigenschaften von Programmiersprachen

<!-- # Positive/Advantageous/Desirable Characteristics/Properties of Programming Languages
# Desirable Characteristics of Programming Languages
# Influences on Language Design
# Eveluation Criteria -->

<!--
Crucial to achieving this goal is to find out which features of a programming language are beneficial.
These are then evaluated in terms of how they affect the software development process, including maintenance.
Such a list of characteristics is necessarily controversial,
as it is difficult to get everyone to agree on the value of some given language property relative to others.
In spite of these differences, most would probably agree that the following criteria are at least important.
-->
Entscheidend für das Erreichen dieses Ziels ist es, herauszufinden, welche Eigenschaften einer Programmiersprache vorteilhaft sind.
Diese werden dann bewertet, wie sie den Softwareentwicklungsprozess, einschließlich der Wartung, beeinflussen.
Eine solche Liste von Merkmalen ist zwangsläufig umstritten,
da es schwierig ist, alle Beteiligten dazu zu bringen, sich über den Wert einer bestimmten Spracheigenschaft im Vergleich mit anderen einig zu sein.
Trotz dieser Unterschiede würden die meisten wahrscheinlich zustimmen, dass die folgenden Kriterien zumindest wichtig sind.
[@stansifer_1995 S. 60; @sebesta_2019 S. 41]

<!-- ## Readability -->
## Lesbarkeit

<!--
One key criteria for judging a programming language is the ease with which programs can be read and understood.
Source code written in our new language will possibly be read more often then written
and maintenance, where a lot of reading happens, is as a major part of the developement cycle.
Because ease of maintenance is determined in large part by the
readability of programs, readability is an important measure to improve the
quality of programs and programming languages.
-- Readability should be considered in the context of the problem domain. --
__TODO CONTEXT OF RYM__
The following subsections describe characteristics that contribute to the
readability of a programming language.
-->
Ein wichtiges Kriterium für die Beurteilung einer Programmiersprache ist die Leichtigkeit, mit der Programme gelesen und verstanden werden können.
Der in unserer neuen Sprache geschriebene Quellcode wird möglicherweise öfter gelesen als geschrieben
und die Wartung, bei der viel gelesen wird, ist ein wichtiger Teil des Entwicklungszyklus.
Da die Wartungsfreundlichkeit zu einem großen Teil durch die Lesbarkeit von Programmen bestimmt wird,
ist sie eine wichtige Maßnahme zur Verbesserung der Qualität von Programmen und Programmiersprachen.
In den folgenden Unterabschnitten werden Merkmale beschrieben, die zur Lesbarkeit einer Programmiersprache beitragen.
[@sebesta_2019 S. 42f]

<!-- ### Simplicity -->
### Einfachheit

<!--
The overall simplicity of a programming language strongly affects its readability.
A language with a large number of basic constructs is more difficult to understand than a simpler one.
Programmers who must use a complex language often learn just a subset of the language and ignore its other features.
This learning pattern is sometimes used to excuse the large number of language constructs, but that argument is not valid.
Readability problems occur whenever the program’s author has learned a different subset from that subset with which the reader is familiar.
-->
Die allgemeine Einfachheit einer Programmiersprache wirkt sich stark auf ihre Lesbarkeit aus.
Eine Sprache mit einer großen Anzahl von Grundkonstrukten ist schwieriger zu verstehen als eine einfachere Sprache.
Programmierer, die eine komplexe Sprache verwenden müssen, lernen oft nur eine Teilmenge der Sprache und ignorieren die anderen Merkmale.
Dieses Lernmuster wird manchmal als Entschuldigung für die große Anzahl von Strukturen herangezogen, aber dieses Argument ist nicht stichhaltig.
Probleme mit der Lesbarkeit treten immer dann auf, wenn der Programmverfasser eine andere Teilmenge gelernt hat als die, mit der der Leser vertraut ist.
[@stansifer_1995 S. 61; @sebesta_2019 S. 43]

<!--
A second complicating characteristic of a programming language is, having more than one way to accomplish the same operation.
@sec-bindings-and-scope will discuss one example of this in more detail.
That example will require operator overloading in Rym,
in which a single operator can have more than one meaning.
Although this is often useful, it can lead to reduced readability if users are allowed to create their own overloading and do not do it sensibly.
For example, it is clearly acceptable to overload "+"" to use it for both integer and floating-point addition.
In fact, this overloading simplifies a language by reducing the number of operators. How the overloading in Rym works is explained in @sec-polymorphism.
-->
Ein zweites Merkmal, das die Lesbarkeit einer Programmiersprache beeinträchtigt, ist die Existenz von mehr als einem Weg, um dieselbe Operation auszuführen.
In @sec-bindings-and-scope wird ein Beispiel dafür näher erläutert.
Dieses Beispiel erfordert die Überladung von Operatoren in Rym,
bei dem ein einzelner Operator mehr als eine Implementierung haben kann.
Obwohl dies oft nützlich ist, kann es zu einer geringeren Lesbarkeit führen, wenn es den Benutzern erlaubt ist, ihre eigenen Überladungen zu erstellen und sie dies nicht vernünftig tun.
So ist es beispielsweise durchaus akzeptabel, "+" zu überladen, um es sowohl für die Ganzzahl- als auch für die Gleitkommaaddition zu verwenden.
In der Tat vereinfacht diese Überladung eine Sprache, indem sie die Anzahl der verschiedenen Operatoren reduziert. Wie das Überladen in Rym funktioniert, wird in @sec-polymorphism erklärt.
[@sebesta_2019 S. 43f]

<!--
On the other hand, simplicity can be taken too far.
For example, the form and meaning of most assembler instructions are very simple.
Since more complex control statements are missing, the programme structure is less obvious.
More of them are needed than in equivalent programs in a higher programming language.
The same arguments apply to the less extreme case of languages with inadequate control and data structures.
-->
Andererseits kann man es mit der Einfachheit auch übertreiben.
Beispielsweise sind Form und Bedeutung der meisten Assembler-Anweisungen sehr einfach.
Da komplexere Steueranweisungen fehlen, ist die Programmstruktur weniger offensichtlich.
Es werden mehr Anweisungen benötigt als in entsprechenden Programmen einer höheren Programmier-sprache.
Die gleichen Argumente gelten auch für den weniger extremen Fall von Sprachen mit unzureichenden Kontroll- und Datenstrukturen.
[@sebesta_2019 S. 44]

- __TODO__
  - as few things to think about at once as possible

<!-- ### Orthogonality -->
### Orthogonalität

<!--
Orthogonality^[The word orthogonal comes from the mathematical concept of orthogonal vectors, which are independent of eachother.] in a programming language means that a small set of primitive constructs can be combined in a small number of ways to build the control and data structures of the language.
Furthermore, every possible combination of primitives should be legal and meaningful.
Therefore, a lack of orthogonality leads to exceptions to the rules of the language.
The more orthogonal the design of a language, the fewer exceptions the language rules require.
Fewer exceptions mean a higher degree of regularity in the design, which makes the language easier to learn, read, and understand.
-->
Orthogonalität^[Das Wort orthogonal stammt aus dem mathematischen Konzept der orthogonalen Vektoren, die voneinander unabhängig sind.] in einer Programmiersprache bedeutet, dass eine kleine Menge von primitiven Konstrukten auf wenige Arten kombiniert werden können, um die Kontroll- und Datenstrukturen der Sprache aufzubauen.
Außerdem sollte jede mögliche Kombination von Primitiven legal und sinnvoll sein.
Ein Mangel an Orthogonalität führt daher zu Ausnahmen von den Regeln der Sprache.
Je orthogonaler der Entwurf einer Sprache ist, desto weniger Ausnahmen erfordern die Sprachregeln.
Weniger Ausnahmen bedeuten einen höheren Grad an Regelmäßigkeit im Design, wodurch die Sprache leichter zu lernen, zu lesen und zu verstehen ist.
[@sebesta_2019 S.44ff]

<!--
The meaning of an orthogonal language feature is independent of the context of its appearance in a program.
But making everything context independent can lead to unnecessary complexity as well.
Because languages require a large number of primitives, a high degree of orthogonality results in an explosion of combinations.
So, even if the combinations are simple, their sheer numbers leads to complexity.
Simplicity in a language, therefore, is at least in part the result of a combination of a relatively small number of primitive constructs and a limited use of the concept of orthogonality.
-->
Die Bedeutung eines orthogonalen Sprachelements ist unabhängig von dem Kontext, in dem es in einem Programm auftritt.
Aber alles kontextunabhängig zu machen, kann auch zu unnötiger Komplexität führen.
Da Sprachen eine große Anzahl von Primitiven benötigen, führt ein hoher Grad an Orthogonalität zu einer Explosion an Kombinationen.
Auch wenn Kombinationen einfach sind, erzeugt ihre Anzahl Komplexität.
Die Einfachheit einer Sprache ist daher zumindest teilweise das Ergebnis einer Kombination aus einer relativ kleinen Anzahl von primitiven Konstrukten und einer begrenzten Verwendung des Konzepts der Orthogonalität.
[@stansifer_1995 S.60f; @sebesta_2019 S.46f]

<!-- ### Data Types -->
### Datentypen

Readability can be increased even more by allowing users to define adequate data types and data structures for specific use cases.
This especially applies to Booleans and Enumerations covered in @sec-bool and @sec-enum respectively.
For example, in some languages that do not provide a Boolean type the following code could be used:

```rym
const timeout = 1
```

The meaning of this statement is unclear, whereas in a language that includes Boolean types, the following would be used:

```rym
const timeout = true
```
Which is clearer than the first one.
[@sebesta_2019 S. 47]

### Syntax

[@sebesta_2019 S. 48f]

- __TODO__
  - simple
  - expressive
  - flat learning curve
  - familiar syntax
  - `{}` is a block (vs. `end`/`end if`)
  - might not make as much sense for non-programmers
  - comparable with the way that `+` and other math notation could be considered less readable then `plus`

<!-- ## Writability -->
## Schreibbarkeit

<!-- TODO -->
Writability is a measure of how easily a language can be used to create programs for a chosen problem domain.
Most of the language characteristics that affect readability also affect writability.
This follows directly from the fact that the process of writing a program requires the programmer frequently to reread the part of the program that is already written.
As is the case with readability, writability must be considered in the context of the target problem domain of a language.

<!-- ## Reliability -->
## Verlässlichkeit

A program is said to be reliable if it performs to its specifications under all
conditions and will continue to in the future.
[@sebesta_2019 S. 51]

<!-- ### Specification -->
### Spezifikation

A programming language without a standardised specification can hardly be considered reliable.
This specification is a set of rules that an implementation of the language must obey to ensure that programs behave as intended.
It should cover all possible combinations of programming language features.

In some cases, the behaviour of certain features may be poorly defined,
either to make programs run optimally on certain platforms or because no one has thought of the exact combination.
This can lead to different implementations that produce different results.
Some of the possible outcomes can be harmful and implementations are not required to remain consistent across executions,
implementation versions, or levels of optimisation.
[@iso_24772_1_2019 S. 21; @michell_2009 S. 190]

Behaviours that are not mentioned in the specification are called _unspecified behaviour_,
and _undefined behaviour_ if they are mentioned, but it is not defined how they behave.
They pose a significant challenge to users of the language, as they cannot be sure how and whether their program will run.
For this reason, a language should have as few of them as possible.
[@iso_24772_1_2019 S. 21]

<!-- ### Open Source -->

<!--
Open source programming languages are those whose source code is freely available for anyone to use, modify, and distribute. This can be a significant advantage for software development, as it allows for a wider range of people to contribute to the language, which can lead to more innovation and faster development. Additionally, open source languages allow for more transparency, which can improve trust in the language and the programs created with it.
Future Proof

A future-proof programming language is one that is designed to be able to evolve and adapt over time. This can be an important characteristic for a language to have, as it allows for the language to remain relevant and useful even as technology and programming practices change.

One way that a language can be future-proof is by allowing for breaking changes. Breaking changes refer to changes that alter the way the language works in such a way that existing programs may no longer work as intended. While these changes can be disruptive in the short term, they can also be necessary for the language to evolve and adapt to new technology and programming practices.

Another way that a language can be future-proof is by reserving keywords. Reserved keywords are words that are reserved for specific use in the language, and cannot be used as variable or function names. This can allow for the language to introduce new features and functionality without causing conflicts with existing programs.

Overall, having a language that is future-proof allows for the language to stay relevant and useful for a longer period of time, thus making it more reliable for the development process.
-->

<!-- ### Safety -->
### Sicherheit

<!-- Safety is also an important aspect of specification, as it helps to avoid undefined behavior and aliasing, which can lead to unexpected and unpredictable results. Type checking is another important aspect of specification, as it helps to ensure that the program is using the correct data types in the correct way, which can help to prevent errors and improve the overall reliability of the program. -->

- __TODO__
  - aliasing
  - type checking

<!-- ### Future Proof -->
### Zukunftssicherheit

- __TODO__
  - allow breaking changes
  - reserved keywords

<!-- Portability

Portability is another important characteristic of a programming language. A program that is portable can be easily adapted to different platforms and environments. This is especially important for programs that are intended to be used in multiple locations or by -->

<!--
Certain languages (e.g., Smalltalk and Python) are sometimes referred to as
“interpreted languages” because most of their semantic error checking must
be performed at run time. Certain other languages (e.g., Fortran and C)
are sometimes referred to as “compiled languages” because almost all of their
semantic error checking can be performed statically. This terminology isn’t
strictly correct: interpreters for C and Fortran can be built easily, and a com-
piler can generate code to perform even the most extensive dynamic semantic
checks. That said, language design has a profound effect on “compilability.”
@scott_2016
 -->

{{< pagebreak >}}
