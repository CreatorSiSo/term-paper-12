<!-- Rym Source Code Examples -->
# Rym Quellcode Beispiele

## Data Types

### Booleans

```rym
type bool = true | false
use bool.true
use bool.false
```

### Integers

```rym
type int;__TODO__
type uint;__TODO__

0 44 1834
```

### Floats

```rym
type float;__TODO__

0.1 -1.4
-444. // same as -444.0
```

### Text

```rym
type char;__TODO__

'a' '\n' '\t' '\u{2192}'

type string;__TODO__

"Hello World!\n" "testing"
```

### Structures

```rym
type Vec3 = {
  x: float,
  y: float,
  z: float,
}

const pos = Vec3 { x: 2.5, y: -1.2, z: 0.0, }
```

{{< pagebreak >}}

### Enumerations / Union Types

```rym
type EnumName =
  | Variant1
  | Variant2
  | VariantN

const variant = EnumName.VariantN
```

There is also a shorter syntax for small enums.

```rym
type SmallEnum = VerySmall | ActuallyLarge
```

Each variant can be associated with a specific value.
These values are automatically chosen if not defined and are usually represented by an integer.

```rym
type EnumName =
  | Variant1 = 1
  | Variant2 = 2
  | VariantN = 156

const variant_n = EnumName.VariantN
const repr = variant_n as uint       // 156
const variant_2 = 2 as EnumName      // EnumName.Variant2
```

### Builtin Enumerations

The Option type is used for something that might not have a value.

```rym
type Option<T> =
  | Some(T)
  | None

use Option.Some
use Option.None
```

The Result type is used to specify that something can either have a value or contain an error.

```rym
type Result<T, E> =
  | Ok(T)
  | Err(E)

use Result.Ok
use Result.Err
```

## Expressions

### Block

Block expression evaluate to the value of their last statement:

```rym
const outer_index = 0

// evaluates to "One"
{
  const array = ["One", "Two", "Three"]
  array[outer_index]
}
```

They, like any other expression, can be used as an initializer for a variable:

```rym
const outer_index = 0

const one_str = {
  const array = ["One", "Two", "Three"]
  array[outer_index]
}
```

### If..Else

```rym
if expression {
  print("true branch")
}

if expression {
  print("true branch")
} else {
  print("false branch")
}
```

### IfVar..Else

```rym
const maybe_value = Some(2)
if const Some(value) = maybe_value {
  print(value)
}

if const Some(value) = maybe_value {
  print(value)
} else {
  print("None")
}
```

### Match

Used to destructure complex data types like enumerations.

```rym
match maybe_value {
  Some(value) => print(value)
  None => print("None")
}
```

Works just as well with structures.

```rym
match pos {
  Vec3 { x: 0.0, .. } => print("Position: on ground")
  Vec3 { y: 0.0, z: 0.0, .. } => print("Position: on x axis")
  Vec3 { x: 0.0, z: 0.0, .. } => print("Position: on y axis")
  Vec3 { x: 0.0, y: 0.0, .. } => print("Position: on z axis")
  Vec3 { x: 0.0, y: 0.0, z: 0.0 } => print("Position: at origin")
  Vec3 { x, y, z } => print("Position:", x, y, z)
}
```

It is also possible to use "_" as a wildcard for catching all remaining cases.

```rym
match pos {
  Vec3 { x: 0.0, y: 0.0, z: 0.0 } => print("at origin")
  _ => print("not at origin")
}
```

## Statements

### Variables

```rym
const const_name = "Hello World!"

mut mut_name = "Hello "
mut_name += "Universe!"

print(const_name, mut_name) // "Hello World! Hello Universe!/n"
```

Uninitialized variables must have a value assigned to them before they can be used.

```rym
const name

if condition { name = "Simon" } else { name = "Robert" }

// allowed because name always has a value
print(name)
```

### Imports / Use

```rym
use std.fs.{self, File}

const path = "./dad_jokes.txt"
const joke = "What should you do if you meet a giant? Use big words."

const create_result = File.create(path)
const write_result = fs.write(path, joke)
const data = fs.read_to_string(path).unwrap()

print(data) // "What should you do if you meet a giant?
            //  Use big words.\n"
```

### Functions

```rym
func func_name(param_1: Type1, param_2: Type2) -> ReturnType {
  ReturnType
}

const of_return_type = func_name(of_type_1, of_type_2)
```

#### Parameter Default Values

```rym
func increment(num: int, by = 1) -> int {
  num + by
}

const plus_one = increment(100)        // 101
const plus_50 = increment(100, 50)     // 150
const plus_50 = increment(100, by: 50) // 150
```

#### Force Named Arguments

```rym
func testing(pos_or_named: int, .., named: string) { }

testing(2, named: "Hello World!")
testing(2, named: "Hello World!")
testing(pos_or_named: 2, named: "Hello World!")
testing(named: "Hello World!", pos_or_named: 2)
```

{{< pagebreak >}}

#### Variable Arguments

```rym
func concat(..strings: [string], sep = "") -> string {
  strings.join(sep)
}

const name = "Mr. Walker"

// all arguments must be of type string
// they are collected into the strings array
concat("Hello ", name, "!") // "Hello Mr. Walker!"

// arguments defined after the variable argument
// must be passed in by name
concat(2.to_string(), true.to_string(), name, sep: ", ") // "2, true, Mr. Walker"
concat(sep: ", ", 2.to_string(), true.to_string(), name) // "2, true, Mr. Walker"
```

#### Builtin Print Function

```rym
func print(..args: [impl Display], sep = " ", end = "\n") -> @Io {
  mut output = ""
  for arg in args {
    output.push(arg.fmt())
  }
  /* .. */
}

print("Hello World")               // "Hello World\n"
print("Hello World", end: "")      // "Hello World"

print(true, 2, "three")            // "true 2 three\n"
print(true, 2, "three", sep: ", ") // "true, 2, three\n"
```

{{< pagebreak >}}

## Factorial

Two possible implementations for calculating factorials.
Pseudo code from Wikipedia:
```
define factorial(n):
  f := 1
  for i := 1, 2, 3, ..., n:
    f := f × i
  return f
```

### Imperative approach

```rym
func factorial(n: uint) -> uint {
  mut result = 1
  for const i in 1..=n {
    result *= i
  }
  result
}
```

### Declarative approach

```rym
func factorial(n: uint) -> uint {
	(1..=n).fold(1, (accum, i) -> accum * i)
}
```

{{< pagebreak >}}

## Find Summands

```rym
/// Function for finding two items in a list,
/// that add up to the given sum.
///
/// numbers array must be sorted
func summands(numbers: [int], sum: int) -> Option<[usize; 2]> {
  mut low = 0
  mut high = numbers.len() - 1

  while low < high {
    const current_sum = numbers[low] + numbers[high]

    if current_sum == sum {
      return Some([numbers[low], numbers[high]])
    } else if current_sum < sum {
      low += 1
    } else {
      high -= 1
    }
  }

  None
}

const numbers = [-14, 1, 3, 6, 7, 7, 12]
const sum = -13

if const Some([left, right]) = summands(numbers, sum) {
  print(f"Sum of {left} and {right} = {sum}")
} else {
  print("Pointers have crossed, no sum found")
}
```

{{< pagebreak >}}
