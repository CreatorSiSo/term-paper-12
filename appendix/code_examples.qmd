<!-- Rym Source Code Examples -->
# Rym Quellcode Beispiele

## Data Types

### Booleans

```rym
enum bool {
  true,
  false,
}
use bool.true
use bool.false
```

### Numbers

```rym
type int
type uint
```

```rym
type float
```

### Text

```rym
type char
type string
```

### Other

```rym
type Option<T> = None | Some(T)
use Option.Some
use Option.None
```

{{< pagebreak >}}

## Statements

### Variables

Uninitialized variables must have a value assigned to them before they can be used.

```rym
const name
const name: OptionalType
```

## Expressions

### Block

Block expression evaluate to the value of their last statement:

```rym
const outer_index = 0

// evaluates to "One"
{
  const array = ["One", "Two", "Three"]
  array[outer_index]
}
```

They, like any other expression, can be used as an initializer for a variable:

```rym
const outer_index = 0

const one_str = {
  const array = ["One", "Two", "Three"]
  array[outer_index]
}
```

### If..Else

```rym
if expression {
  print("true branch")
}

if expression {
  print("true branch")
} else {
  print("false branch")
}
```

### IfVar..Else

```rym
const maybe_value = Some(2)
if const Some(value) = maybe_value {
  print(value)
}

if const Some(value) = maybe_value {
  print(value)
} else {
  print("None")
}
```

## Functions

```rym
func func_name(param_1: Type1, param_2: Type2) -> ReturnType {
  ReturnType
}
```

### Parameter Default Values

```rym
func increment(num: int, by = 1) -> int {
  num + by
}

const plus_one = increment(100)        // 101
const plus_50 = increment(100, 50)     // 150
const plus_50 = increment(100, by: 50) // 150
```

### Force Named Arguments

```rym
func testing(pos_or_named: int, .., named: string) { }

testing(2, named: "Hello World!")
testing(2, named: "Hello World!")
testing(pos_or_named: 2, named: "Hello World!")
testing(named: "Hello World!", pos_or_named: 2)
```

### Variable Arguments

```rym
func concat(..strings: [string], sep = "") -> string {
  strings.join(sep)
}

const name = "Mr. Walker"

// all arguments must be of type string
// they are collected into the strings array
concat("Hello ", name, "!") // "Hello Mr. Walker!"

// arguments defined after the variable argument
// must be passed in by name
concat(2.to_string(), true.to_string(), name, sep: ", ") // "2, true, Mr. Walker"
concat(sep: ", ", 2.to_string(), true.to_string(), name) // "2, true, Mr. Walker"
```

## Print Function

```rym
func print(..args: [impl Display], sep = " ", end = "\n") -> @Io {
  mut output = ""
  for arg in args {
    output.push(arg.fmt())
  }
  /* .. */
}

print("Hello World")               // "Hello World\n"
print("Hello World", end: "")      // "Hello World"

print(true, 2, "three")            // "true 2 three\n"
print(true, 2, "three", sep: ", ") // "true, 2, three\n"
```

{{< pagebreak >}}

## Factorial

Two possible implementations for calculating factorials.
Pseudo code from Wikipedia:
```
define factorial(n):
  f := 1
  for i := 1, 2, 3, ..., n:
    f := f × i
  return f
```

### Imperative approach

```rym
func factorial(n: uint) -> uint {
  mut result = 1
  for const i in 1..=n {
    result *= i
  }
  result
}
```

### Declarative approach

```rym
func factorial(n: uint) -> uint {
	(1..=n).fold(1, (accum, i) -> accum * i)
}
```

{{< pagebreak >}}

## Find Summands

```rym
/// Function for finding two items in a list,
/// that add up to the given sum.
///
/// numbers array must be sorted
func summands(numbers: [int], sum: int) -> Option<[usize; 2]> {
  mut low = 0
  mut high = numbers.len() - 1

  while low < high {
    const current_sum = numbers[low] + numbers[high]

    if current_sum == sum {
      return Some([numbers[low], numbers[high]])
    } else if current_sum < sum {
      low += 1
    } else {
      high -= 1
    }
  }

  None
}

const numbers = [-14, 1, 3, 6, 7, 7, 12]
const sum = -13

if const Some([left, right]) = summands(numbers, sum) {
  print(f"Sum of {left} and {right} = {sum}")
} else {
  print("Pointers have crossed, no sum found")
}
```

{{< pagebreak >}}
