<!-- Rym Source Code Examples -->
# Rym Quellcode Beispiele

## Data Types

### Booleans

```rym
enum bool {
  true,
  false,
}
use bool.true
use bool.false
```

### Numbers

```rym
type int
type uint
```

```rym
type float
```

### Text

```rym
type char
type string
```

### Other

```rym
type Option<T> = None | Some(T)
use Option.Some
use Option.None
```

<!-- ```rym
// TODO
// If you want access to the ordinal value of an enum, you
// can specify the tag type.
const Value = enum(u2) {
  Zero,
  One,
  Two,
}
// Now you can cast between u2 and Value.
// The ordinal value starts from 0, counting up by 1 from the previous member.
test "enum ordinal value" {
  assert_eq(@enumToInt(Value.Zero), 0)
  assert_eq(@enumToInt(Value.One), 1)
  assert_eq(@enumToInt(Value.Two), 2)
}
```

You can override the ordinal value for an `enum`.

```rym
enum Value2 {
  Hundred = 100,
  Thousand = 1_000,
  Million = 1_000_000,
}
test "set enum ordinal value" {
  // TODO: How to convert enum to int/uint?
  assert_eq(@enumToInt(Value2.Hundred), 100)
  assert_eq(@enumToInt(Value2.Thousand), 1000)
  assert_eq(@enumToInt(Value2.Million), 1000000)
}
```

You can also override only some values.

```rym
enum Value3 {
  A,
  B = 8,
  C,
  D = 4,
  E,
}
test "enum implicit ordinal values and overridden values" {
  assert_eq(@enumToInt(Value3.A), 0)
  assert_eq(@enumToInt(Value3.B), 8)
  assert_eq(@enumToInt(Value3.C), 9)
  assert_eq(@enumToInt(Value3.D), 4)
  assert_eq(@enumToInt(Value3.E), 5)
}
```

`Enum`s can have methods, the same as `struct`s.
`Enum` methods are not special, they are only namespaced functions that you can call with dot syntax.

```rym
enum Suit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,

  pub fn isClubs(self: Suit) bool {
    self == Suit.Clubs
  }
}
test "enum method" {
  const suit = Suit.Spades
  assert_eq(suit.isClubs(), false)
}
```

An `enum` can be `match`ed upon.

```rym
enum Foo {
  String,
  Number,
  None,
}
test "enum match" {
  const foo = Foo.Number
  const what_is_it = match foo {
    Foo.String => "this is a string",
    Foo.Number => "this is a number",
    Foo.None => "this is a none",
  }
  assert_eq(what_is_it, "this is a number")
}
```

```rym
// TODO
// `@typeInfo` can be used to access the integer tag type of an enum.
enum Small {
  One,
  Two,
  Three,
  Four,
}
test "std.meta.Tag" {
  assert_eq(@typeInfo(Small).Enum.tag_type, u2)
}

// `@typeInfo` tells us the field count and the fields names:
test "@typeInfo" {
  assert_eq(@typeInfo(Small).Enum.fields.len, 4)
  assert_eq(@typeInfo(Small).Enum.fields[1].name, "Two")
}

// `@tagName` gives a `string` representation of an enum value:
test "@tagName" {
  assert_eq(@tagName(Small.Three), "Three")
}
```

### Non-exhaustive enum

A non-exhaustive enum can be created by adding an underscore as the last field.
Non-exhaustive means the enum might gain additional variants in the future,
so <!-- it must specify a tag type and --> when unpacking the enum it is required to add a fall through case.

```rym
// TODO: Use #NonExhaustive Attribute insted?
#NonExhaustive
enum Number {
  One,
  Two,
  Three,
  _,
}

test "match on non-exhaustive enum" {
  const number = Number.One
  const result = match number {
    .One => true,
    .Two | .Three => false,
    _ => false,
  }
  assert(result)
  const is_one = match number {
      .One => true,
      else => false,
  }
  assert(is_one)
}
```

```rym
type bool = true | false
type Testing = One | Other

enum Option<T> = {
  Some(T),
  None,
}

struct Something {
  x: uint,
  y: uint,
}
``` -->

{{< pagebreak >}}

## Statements

### Variables

Uninitialized variables must have a value assigned to them before they can be used.

```rym
const name
const name: OptionalType
```

## Expressions

### Block

Block expression evaluate to the value of their last statement:

```rym
const outer_index = 0

// evaluates to "One"
{
  const array = ["One", "Two", "Three"]
  array[outer_index]
}
```

They, like any other expression, can be used as an initializer for a variable:

```rym
const outer_index = 0

const one_str = {
  const array = ["One", "Two", "Three"]
  array[outer_index]
}
```

### If..Else

```rym
if expression {
  print("true branch")
}

if expression {
  print("true branch")
} else {
  print("false branch")
}
```

### IfVar..Else

```rym
const maybe_value = Some(2)
if const Some(value) = maybe_value {
  print(value)
}

if const Some(value) = maybe_value {
  print(value)
} else {
  print("None")
}
```

## Functions

```rym
func func_name(param_1: Type1, param_2: Type2) -> ReturnType {
  ReturnType
}
```

### Parameter Default Values

```rym
func increment(num: int, by = 1) -> int {
  num + by
}

const plus_one = increment(100)        // 101
const plus_50 = increment(100, 50)     // 150
const plus_50 = increment(100, by: 50) // 150
```

### Force Named Arguments

```rym
func testing(pos_or_named: int, .., named: string) { }

testing(2, named: "Hello World!")
testing(2, named: "Hello World!")
testing(pos_or_named: 2, named: "Hello World!")
testing(named: "Hello World!", pos_or_named: 2)
```

### Variable Arguments

```rym
func concat(..strings: [string], sep = "") -> string {
  strings.join(sep)
}

const name = "Mr. Walker"

// all arguments must be of type string
// they are collected into the strings array
concat("Hello ", name, "!") // "Hello Mr. Walker!"

// arguments defined after the variable argument
// must be passed in by name
concat(2.to_string(), true.to_string(), name, sep: ", ") // "2, true, Mr. Walker"
concat(sep: ", ", 2.to_string(), true.to_string(), name) // "2, true, Mr. Walker"
```

## Print Function

```rym
func print(..args: [impl Display], sep = " ", end = "\n") -> @Io {
  mut output = ""
  for arg in args {
    output.push(arg.fmt())
  }
  /* .. */
}

print("Hello World")               // "Hello World\n"
print("Hello World", end: "")      // "Hello World"

print(true, 2, "three")            // "true 2 three\n"
print(true, 2, "three", sep: ", ") // "true, 2, three\n"
```

{{< pagebreak >}}

## Factorial

Two possible implementations for calculating factorials.
Pseudo code from Wikipedia:
```
define factorial(n):
  f := 1
  for i := 1, 2, 3, ..., n:
    f := f × i
  return f
```

### Imperative approach

```rym
func factorial(n: uint) -> uint {
  mut result = 1
  for const i in 1..=n {
    result *= i
  }
  result
}
```

### Declarative approach

```rym
func factorial(n: uint) -> uint {
	(1..=n).fold(1, (accum, i) -> accum * i)
}
```

{{< pagebreak >}}

## Find Summands

```rym
/// Function for finding two items in a list,
/// that add up to the given sum.
///
/// numbers array must be sorted
func summands(numbers: [int], sum: int) -> Option<[usize; 2]> {
  mut low = 0
  mut high = numbers.len() - 1

  while low < high {
    const current_sum = numbers[low] + numbers[high]

    if current_sum == sum {
      return Some([numbers[low], numbers[high]])
    } else if current_sum < sum {
      low += 1
    } else {
      high -= 1
    }
  }

  None
}

const numbers = [-14, 1, 3, 6, 7, 7, 12]
const sum = -13

if const Some([left, right]) = summands(numbers, sum) {
  print(f"Sum of {left} and {right} = {sum}")
} else {
  print("Pointers have crossed, no sum found")
}
```

{{< pagebreak >}}
