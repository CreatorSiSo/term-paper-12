<!-- Rym Overview -->
# Rym Überblick

<!-- Most of the following structures are automatically imported for every file. -->

<!-- ## Data Types -->
## Datentypen

### Booleans

```rym
type bool = true | false
use bool.true
use bool.false
```

### Integers

```rym
0 44 1834
```

### Floats

```rym
0.1 -1.4
-444. // same as -444.0
```

### Text

```rym
type char

'a' '\n' '\t' '\u{2192}'

type string

"Hello World!\n" "testing"
```

### Structures {#sec-appendix-structs}

```rym
type Vec3 = {
  x: float,
  y: float,
  z: float,
}

const pos = Vec3 { x: 2.5, y: -1.2, z: 0.0, }
```

### Enumerationen / Vereinigungstypen {#sec-appendix-unions}

```rym
type EnumName =
  | Variant1
  | Variant2
  | VariantN

const variant = EnumName.VariantN
```

<!-- There is also a shorter syntax for small enums: -->
Für kleine Enumerationen gibt es auch eine kürzere Syntax:

```rym
type SmallEnum = VerySmall | ActuallyLarge
```
<!--
Each variant can be associated with a specific value.
These values are automatically chosen if not defined and are usually represented by an integer:
-->
Jede Variante kann mit einem bestimmten Wert verknüpft werden.
Diese Werte werden automatisch ausgewählt, wenn sie nicht definiert sind,
und werden normalerweise durch Integers dargestellt:

```rym
type EnumName =
  | Variant1 = 1
  | Variant2 = 2
  | VariantN = 156

const variant_n = EnumName.VariantN
const repr = variant_n as uint       // 156
const variant_2 = 2 as EnumName      // EnumName.Variant2
```

<!-- ### Builtin Enumerations -->
### Eingebaute Enumerationen

<!-- The Option type is used for something that might not have a value. -->
Der Option-Typ wird für etwas verwendet, das möglicherweise keinen Wert hat:

```rym
type Option<T> =
  | Some(T)
  | None

use Option.Some
use Option.None
```

<!-- The Result type is used to specify that something can either have a value or contain an error. -->
Der Result-Typ wird verwendet, um anzugeben, dass etwas entweder einen Wert oder einen Fehler enthalten kann:

```rym
type Result<T, E> =
  | Ok(T)
  | Err(E)

use Result.Ok
use Result.Err
```

{{< pagebreak >}}

## Expressions {#sec-appendix-expressions}

### Block

<!-- Block expression evaluate to the value of their last statement and, like any other expression, they can be used as an initializer for a variable: -->
Blockausdrücke geben den Wert ihrer letzten Anweisung zurück und können, wie jeder andere Ausdruck, als Initialisierer für eine Variable verwendet werden:

```rym
const outer_index = 0

const str = {
  const array = ["One", "Two", "Three"]
  array[outer_index]
}
print(str) // "One\n"
```

### If..Else

```rym
if expression {
  print("true branch")
}

if expression {
  print("true branch")
} else {
  print("false branch")
}
```

### IfVar..Else

```rym
const maybe_value = Some(2)
if const Some(value) = maybe_value {
  print(value)
} else {
  print("None")
}
```

### "?" Operator {#sec-qestion-mark-op}

```rym
func read_to_string(path: string) -> Result<string, IoError> {
  mut file = File.open(path)?
  mut data = ""
  file.read_to_string(mut data)?
  Ok(data)
}
```

{{< pagebreak >}}

### Match

<!-- Used to destructure complex data types like enumerations: -->
Dient der Destrukturierung komplexer Datentypen wie Enumerationen:

```rym
match maybe_value {
  Some(value) => print(value)
  None => print("None")
}
```

<!-- And works just as well with structures. -->
Und funktioniert genauso gut mit Strukturen:

```rym
match pos {
  Vec3 { x: 0.0, .. } => print("Position: on ground")
  Vec3 { y: 0.0, z: 0.0, .. } => print("Position: on x axis")
  Vec3 { x: 0.0, z: 0.0, .. } => print("Position: on y axis")
  Vec3 { x: 0.0, y: 0.0, .. } => print("Position: on z axis")
  Vec3 { x: 0.0, y: 0.0, z: 0.0 } => print("Position: at origin")
  Vec3 { x, y, z } => print("Position:", x, y, z)
}
```

<!-- It is also possible to use "_" as a wildcard for catching all remaining cases. -->
Es ist auch möglich, "_" als Platzhalter zu verwenden, um alle übrigen Fälle zu erfassen:

```rym
match pos {
  Vec3 { x: 0.0, y: 0.0, z: 0.0 } => print("at origin")
  _ => print("not at origin")
}
```

<!-- ### TODO: Loop
### TODO: While
### TODO: For -->

### Closures {#sec-appendix-closures}

```rym
func twice(f: func(i32) -> i32) -> func(i32) -> i32 {
  x -> f(f(x))
}

func plus_three(i: i32) -> i32 {
  i + 3
}

const plus_three_twice = twice(plus_three)
print(f"{plus_three_twice(10)}") // 16
```

```rym
func twice(f: func(i32) -> i32) -> func(i32) -> i32 {
  x -> f(f(x))
}

const plus_three_twice = twice(i -> i + 3)
print(f"{plus_three_twice(10)}") // 16
```

## Statements

### Variables {#sec-appendix-variables}

```rym
// unveränderliche variable
const const_name = "Hello World!"

// änderbare variable
mut mut_name = "Hello "
mut_name += "Universe!"

print(const_name, mut_name) // "Hello World! Hello Universe!/n"
```

<!-- Uninitialized variables must have a value assigned to them before they can be used. -->
Nicht initialisierte Variablen müssen mit einem Wert versehen werden, bevor sie verwendet werden können:

```rym
const name

if condition { name = "Simon" } else { name = "Robert" }

// erlaubt, da "name" immer einen Wert hat
print(name)
```
<!-- // allowed because name always has a value -->

### Use

```rym
use std.fs.{self, File}

const path = "./dad_jokes.txt"
const joke = "What should you do if you meet a giant? Use big words."

const create_result = File.create(path)
const write_result = fs.write(path, joke)
const data = fs.read_to_string(path).unwrap()

print(data) // "What should you do if you meet a giant?
            //  Use big words.\n"
```

{{< pagebreak >}}

### Funktionen {#sec-appendix-functions}

```rym
func func_name(param_1: Type1, param_2: Type2) -> ReturnType {
  ReturnType
}

const of_return_type = func_name(of_type_1, of_type_2)
```

### Scope {#sec-appendix-scope}

<!--
When the function "changeX(3)" is called, a new scope is created containing the parameter "x" initialised with the value "3".
The outer variable "x" is not accessible inside the function scope and therefore does not affect the value of x.
The variable "y" is also defined within this scope and initialised with the value 10.
The body of the function is executed and the value of "x + y" (13) is returned.
The function scope is then destroyed and the original scope is restored, resulting in the value "13" being assigned to the variable "result".
-->
Wenn die Funktion "changeX(3)" aufgerufen wird, wird ein neuer Bereich erstellt, der den Parameter "x" enthält, welcher mit dem Wert "3" initialisiert wird.
Die äußere Variable "x" ist innerhalb des Bereichs der Funktion nicht zugänglich und hat daher keinen Einfluss.
Die Variable "y" wird ebenfalls in diesem Bereich definiert und mit dem Wert 10 initialisiert.
Der Hauptteil der Funktion wird ausgeführt und der Wert von "x + y" (13) zurückgegeben.
Anschließend wird der Funktionsbereich zerstört und der ursprüngliche Bereich wiederher-gestellt, so dass der Wert "13" der Variablen "result" zugewiesen wird.

```rym
const x = 5

func changeX(x: i32) -> i32 {
  const y = 10
  return x + y
}

const result = changeX(3) // result = 13
```

<!-- #### Parameter Default Values -->
#### Standardwerte für Parameter

```rym
func increment(num: i32, by = 1) -> i32 {
  num + by
}

const plus_one = increment(100)        // 101
const plus_50 = increment(100, 50)     // 150
const plus_50 = increment(100, by: 50) // 150
```

<!-- #### Force Named Arguments -->
#### Erzwingen von benannten Argumenten

```rym
func testing(pos_or_named: i32, .., named: string) { }

testing(2, named: "Hello World!")
testing(2, named: "Hello World!")
testing(pos_or_named: 2, named: "Hello World!")
testing(named: "Hello World!", pos_or_named: 2)
```

<!-- #### Variable Arguments -->
#### Variable Argumente

```rym
func concat(..strings: [string], sep = "") -> string {
  strings.join(sep)
}

const name = "Mr. Walker"

concat("Hello ", name, "!") // "Hello Mr. Walker!"

concat(2.to_string(), true.to_string(), name, sep: ", ") // "2, true, Mr. Walker"
concat(sep: ", ", 2.to_string(), true.to_string(), name) // "2, true, Mr. Walker"
```

<!-- #### Builtin Print Function -->
#### Eingebaute Print Function

```rym
func print(..args: [impl Display], sep = " ", end = "\n") -> @Io {
  mut output = ""
  for arg in args {
    output.push(arg.fmt())
  }
  /* .. */
}

print("Hello World")               // "Hello World\n"
print("Hello World", end: "")      // "Hello World"

print(true, 2, "three")            // "true 2 three\n"
print(true, 2, "three", sep: ", ") // "true, 2, three\n"
```

### Implementationen {#sec-appendix-impl}

<!-- Every type can have several "impl" blocks,
that must be located in the same module as the type.
They hold static/non-static methods and internal types.
These methods are private by default and can be made public with the "pub" keyword. -->
Jeder Typ kann mehrere "impl"-Blöcke haben,
welche sich im selben Modul wie der Typ befinden müssen.
Sie enthalten statische/nicht-statische Methoden und interne Typen.
Standardmäßig sind Methoden privat und können mit dem Schlüsselwort "pub" öffentlich gemacht werden:

```rym
impl bool {
  pub func then_some<T>(self, value: T) -> Option<T> {
    if self { Some(value) } else { None }
  }
}
```

{{< pagebreak >}}

### Traits / Typ-Klassen

<!-- Traits are used to define common functionality between types: -->
Traits werden verwendet, um gemeinsame Funktionen zwischen Typen zu definieren:

```rym
trait Default {
  func default() -> Self
}
```

<!-- They are implemented for specific types through separate implementations: -->
Sie werden für bestimmte Typen durch separate Implementierungen umgesetzt:

```rym
impl Default for bool { func default() -> Self { false } }

impl Default for i32 { func default() -> Self { 0 } }

impl Default for string { func default() -> Self { "" } }

impl<T> Default for [T] { func default() -> Self { [] } }
```

<!-- This is also how iterators are specified in Rym: -->
Auf diese Weise werden auch Iteratoren in Rym definiert:

```rym
trait Iterator {
  type Item

  func next(mut self) -> Option<Self.Item>
}
```

<!-- These iterators can be used to implement a simple counter like the following or to go over all items of an array one by one. -->
Diese Iteratoren können verwendet werden, um einen einfachen Zähler wie den folgenden umzusetzen oder um beispielsweise alle Elemente eines Arrays einzeln zu durchlaufen.

```rym
type Counter = { count: usize, max: usize }

impl Iterator for Counter {
  type Item = usize

  func next(mut self) -> Option<Self.Item> {
    self.count += 1

    if self.count <= self.max { Some(self.count) } else { None }
  }
}

mut counter = Counter { count: 0, max: 3 }

print(counter.next()) // Some(1)
print(counter.next()) // Some(2)
print(counter.next()) // Some(3)
print(counter.next()) // None
```
